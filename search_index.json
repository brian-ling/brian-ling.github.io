[["index.html", "STAT 362 R for Data Science Syllabus", " STAT 362 R for Data Science Brian Ling 2021-01-24 Syllabus STAT 362 R for Data Science Department of Mathematics and Statistics, Queens University Course Description: Introduction to R, data creation and manipulation, data import and export, scripts and functions, control flow, debugging and profiling, data visualization, statistical inference, Monte Carlo methods, decision trees, support vector machines, neural network, numerical methods. Format and Time: Each week: Two asynchronous lectures will be uploaded on Tue and Wed. We will have one synchronous lecture (not mandatory) on Thu (10:30-11:20am) via zoom. Meeting link: see onQ. Recording of the synchronous lecture will be uploaded to onQ. All times are Kingston Time Annoucement, Schedule, Lecture notes: https://brian-ling.github.io/ The same annoucement will also be posted in onQ. Instructor: Brian Ling (bl90@queensu.ca) Teacher assistant: Xinyi GE (16xg3@queensu.ca), Na LI (18nl6@queensu.ca). They will be responsible for grading your assignments. Office Hours: Wed 9pm-10pm, Thu 1pm-2pm, Fri 10:00-10:30am, or by appointment (let me know if you cannot attend any of these) Meeting link: see onQ (same as the link for the synchronous lecture) Intended Student Learning Outcomes: Understand the fundamental concepts in R Be able to import and tidy data for further analysis Be able to visualize data and perform exploratory data analysis Be able to apply appropriate methods for statistical analysis and interpret the output Be able to apply common machine learning algorithms with real-world applications Understand the basics of numerical and Monte Carlo methods Prerequisite: (STAT 263/3.0 or STAT 268/3.0) and MATH 120/3.0 or MATH 121/3.0 or MATH 124/3.0 MATH 126/3.0 or MATH 110/6.0 or MATH 111/6.0 or (MATH 112/3.0 and MATH 212/3.0) or permission of the department. In words, you need to understand probability and statistics, linear algebra (matrix operations), and basic calculus. Lecture Notes: See https://brian-ling.github.io/. Pdf in onQ. Lecture Videos See onQ. Main Textbooks/Readings: R for Data Science, by Garrett Grolemund and Hadley Wickham (https://r4ds.had.co.nz/) Machine Learning with R, by Brett Lantz R Cookbook, by J.D. Long &amp; Paul Teetor (https://rc2e.com/) Other Reference Textbooks/Readings: R Markdown: The Definitive Guide, by Yihui Xie, J. J. Allaire, Garrett Grolemund (https://bookdown.org/yihui/rmarkdown/) R Graphics Cookbook, by Winston Chang (https://r-graphics.org/) An introduction to R, by W. N. Venables, D. M. Smith and the R Core Team (https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf) Course Outline: R Basic Installing R, Rstudio and packages Basic data types and operations Data structures: vector, matrix, array, list, dara frame Data input and output Scripts and functions Control flow Data visualization with ggplot2 Data manipulation with tidyverse Statistical inference in R: one/two-sample test of mean and proportion; correlation test; non-parametric test; regression analysis Some machine learning methods: nearest neighbors, naive Bayes, decision trees, support vector machines, neural network, k-means clustering Introduction to numerical methods: Monte Carlo simulation, gradient descent, Newton Raphson algorithm Note: actual topics may change slightly depending on our progress Grading Scheme: 30% assignments, 30% Quizzes, 40% Final Project Assignments (30%): There will be approximately 6 Assignments. Late submission: receive 80% of the points (within one day), receive 0 (after one day). No exception other than academic accommodation and academic consideration for an extenuating circumstance. Solution will be posted after one day of the due date. One assignment with the lowest score will be dropped. It is recommended to use R Markdown to write your assignment (https://rmarkdown.rstudio.com/lesson-1.html, R Cookbook Ch.16). A template for this will be discussed. Quizzes (30%): Weekly quizzes. Simple questions will be posted on Thursday each week and each quiz is due on Sunday midnight (receive 80% afterwards). You should be able to answer them after attending the lectures. Two quizzes with the lowest score will be dropped. We have 12 weeks. So each quiz is worth 3% after dropping 2 quizzes with the lowest score. Final Project (40%): Form a group of 5-6 students. TA will help with assignment of the group if you cannot find one. 20% is from the final report. 20% is from the final presentation. All members in the group have to present (more details later). The members are expected to know every part of the project. Send your group member list (first name, last name, Queens email, student ID) to Xinyi GE (16xg3@queensu.ca) by Feb 5. If you cannot find a group, tell Xinyi (first name ,last name, Queens email, student ID, time zone). We will try to form a group for you with the same time zone. Academic Integrity: See https://www.queensu.ca/artsci/node/22/mid/1247 Departures from academic integrity include, but are not limited to, plagiarism, use of unauthorized materials, facilitation, forgery and falsification. Actions which contravene the regulation on academic integrity carry sanctions that can range from a warning, to loss of grades on an assignment, to failure of a course, to requirement to withdraw from the university. "],["schedule.html", "Schedule", " Schedule Lecture Content Reading Asg Quiz Sync Lect 1 Introduction of the course, installation of R and RStudio Syllabus, 1-1.4.1   Lect 2 Factors, Matrix, Lists, Data frames 1.4.1-1.4.5   Lect 3 Operators, built-in functions 1.5-1.6 Quiz 1 (Due Jan 17 11:59pm) Yes (Thu 10:30-11:20am) Lect 4 Shortcuts, probability distributions 1.7-1.9, 2.1 Lect 5 simulation, functions, loops 2.2, 3.1, 3.2 Lect 6 control flow, speed consideration, simulation 3.2-3.5 Quiz 1 (Due Jan 24 11:59pm) Yes (Thu 10:30-11:20am) Reading = lecture notes "],["annoucement.html", "Annoucement", " Annoucement Quiz All the quizzes are not timed. You should not discuss with your friends or seek any help online. Quiz 1 is now available: onQ-&gt; Assessements -&gt; Quizzes-&gt;Quiz 1. Please complete it by Jan 17 at 11:59pm (= Jan 18 at 12:00 am). Assignment Assignment 1: covers the materials in Lect 1-6. "],["introduction.html", "Chapter 1 Introduction 1.1 What is R and RStudio? 1.2 What will you learn in this course? 1.3 Lets Get Started 1.4 R Data Structures 1.5 Operators 1.6 Built-in Functions 1.7 Some Useful RStudio Shortcuts 1.8 Exercises 1.9 Comments to Exercises", " Chapter 1 Introduction 1.1 What is R and RStudio? R R is a language and environment for statistical computing and graphics. R is an interpreted language (individual language expressions are read and then executed immediately as soon as the command is entered) To download R, go to https://cloud.r-project.org/ RStudio is an integrated development environment (IDE) for R programming Install R first, then go to https://rstudio.com/products/rstudio/download/ and download RStudio While you can work in R directly, it is recommended to work in RStudio. 1.2 What will you learn in this course? Note: we do not assume you know R or any programming language before. 1.2.1 R and R as a programming language operators control flow (if..else.., for loop) defining a function 1.2.2 Data Wrangling Data wrangling = the process of tidying and transforming the data 1.2.3 Data Visualization Graphs are powerful to illustrate features of the data. You will learn how to create some basic plots as well as using the package ggplot2 to create more elegant plots. Consider a dataset about cars. library(ggplot2) mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa~ ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa~ ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa~ ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa~ ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa~ ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa~ ## 7 audi a4 3.1 2008 6 auto(av) f 18 27 p compa~ ## 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compa~ ## 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compa~ ## 10 audi a4 quattro 2 2008 4 manual(m6) 4 20 28 p compa~ ## # ... with 224 more rows Among the variables in mpg are: displ, a cars engine size, in litres. hwy, a cars fuel efficiency on the highway, in miles per gallon (mpg). A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance. Scatterplot Scatterplot, points are labeled with colors according to the class variable Scatterplots Line Chart Bar chart Another Bar Chart Boxplot Histogram 1.2.4 Statistical Inference Many problems in different domains can be formulated into hypothesis testing problems. Are university graduates more likely to vote for Candidate A? Is a treatment effective in reducing weights? Is a drug effective in reducing mortality rate? We want to answer these questions that take into account of the intrinsic variability. Formally, we can perform hypothesis testing and compute the confidence intervals. These are what you learned in STAT 269. It is ok if you havent taken the STAT 269. The topics will be briefly reviewed. We will focus on the applications using R. 1.2.5 Machine Learning We will illustrate some machine learning methods using real datasets. For example, Diagnoising breast cancer with the k-NN algorithm Employ Naive Bayes to build an SMS junk message filter (text data) A wordcloud of text data Use neural network to predict the compressive strength of concrete 1.2.6 Some Numerical Methods Monte Carlo simulation (estimate probabilities, expectations, integrals) numerical optimizaiton methods (e.g. maximizing a multi-parameter likelihood function using optim) 1.2.7 Lastly It is important to communicate your results to other after performing the data analysis. Therefore, you will do a project with presentation and report. 1.3 Lets Get Started The best way to learn R is to get started immediately and try the code by yourselves. We will not discuss every topic in detail at the beginning, which is not interesting and unnecessary. We shall revisit the topics when we need additional knowledge. Simple arithmetic expression # can be used a simple calculator 3+5 ## [1] 8 4*2 ## [1] 8 10/2 ## [1] 5 Comment a code: use the hash mark # # this is a comment, R will not run the code behine # Function for combining c(4, 2, 3) # &quot;c&quot; is to &quot;combine&quot; the numbers ## [1] 4 2 3 Assignment (&lt;- is the assignment operator like = in many other programming languages) y &lt;- c(4, 2, 3) # create a vector called y with elements 4, 2, 3 c(1, 3, 5) -&gt; v # c(1,3,5) is assigned to v Output y ## [1] 4 2 3 v ## [1] 1 3 5 R is case-sensitive. When you type Y, you will see an error message: object Y not found Y ## Error in eval(expr, envir, enclos): object &#39;Y&#39; not found 1.4 R Data Structures Reading: ML with R Ch2 Most frequently used data structures in R: vectors, factors, lists, arrays, matrices, data frames 1.4.1 Vectors Vector fundamental R data structure stores an ordered set of values called elements elements must be of the same type Type: integer, double, character, logical Integer, double, logical, character vectors x &lt;- 1:2 # integer vector, we use a:b to form the sequence of integers from a to b typeof(x) # type of the vector ## [1] &quot;integer&quot; x &lt;- c(1.1, 1.2) # double vector typeof(x) ## [1] &quot;double&quot; length(x) # length of the vector x ## [1] 2 x &lt; 2 # logical (TRUE/FALSE) ## [1] TRUE TRUE p &lt;- c(TRUE, FALSE) subject_name &lt;- c(&quot;John&quot;, &quot;Jane&quot;, &quot;Steve&quot;) # character vector Combine two vectors y &lt;- c(2,4,6) c(x, y) # note that we created x above ## [1] 1.1 1.2 2.0 4.0 6.0 c(y, subject_name) # 2, 4, 6 become characters &quot;2&quot;, &quot;4&quot;, &quot;6&quot; ## [1] &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;John&quot; &quot;Jane&quot; &quot;Steve&quot; Assessing elements in the vectors y &lt;- c(2, 4, 6) y[2] # second element ## [1] 4 y[3] # third element ## [1] 6 1.4.2 Factors A factor is a special type of vector that is solely used for representing categorical (male, female/group 1, group 2, group 3) or ordinal (cold, warm, hot/ low, medium, high) variables. Reasons for using factor the category labels are stored only once. E.g., rather than storing MALE, MALE, MALE, FEMALE, the computer may store 1,1,1,2(save memory) many machine learning algorithms treat categorical/ordinal and numeric features differently and may require the input as a factor Create a factor gender &lt;- factor(c(&quot;MALE&quot;, &quot;MALE&quot;, &quot;FEMALE&quot;, &quot;MALE&quot;)) gender ## [1] MALE MALE FEMALE MALE ## Levels: FEMALE MALE # compared with c(&quot;MALE&quot;, &quot;MALE&quot;, &quot;FEMALE&quot;, &quot;MALE&quot;) ## [1] &quot;MALE&quot; &quot;MALE&quot; &quot;FEMALE&quot; &quot;MALE&quot; 1.4.3 Matrix Matrix a collection of numbers in a rectangular form A matrix with dimension n by m means the matrix has n rows and m columns. Create Matrix: To create a \\(3\\times 4\\) matrix with elements 1:12 filled in column-wise A &lt;- matrix(1:12, nrow=3, ncol=4) # note that we use = instead of &lt;- A ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Dimension, number of rows, number of columns of a matrix # again R is case-sensitive, a and A are different dim(A) # to find the dimension of A ## [1] 3 4 nrow(A) # to find the number of row in A ## [1] 3 ncol(A) # to find the number of column in A ## [1] 4 By default, the matrix is filled column-wise. You can change to row-wise by adding byrow = TRUE B &lt;- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE) B ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Select rows, columns, submatrix, element A[1, 2] # select the element in the 1st row and 2nd column ## [1] 4 A[2, ] # select 2nd row ## [1] 2 5 8 11 A[, 3] # select 3rd column ## [1] 7 8 9 A[1:2, 3:4] # select a submatrix ## [,1] [,2] ## [1,] 7 10 ## [2,] 8 11 Try: A[c(1, 2), c(1, 3, 4)] A[-1, ] A[, -2] Combine Two Matrices cbind(A, B) # combine column-wise ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 4 7 10 1 2 3 4 ## [2,] 2 5 8 11 5 6 7 8 ## [3,] 3 6 9 12 9 10 11 12 rbind(A, B) # combine row-wise ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## [4,] 1 2 3 4 ## [5,] 5 6 7 8 ## [6,] 9 10 11 12 Try: rbind(B, A) Transpose x &lt;- c(1, 2, 3) t(x) # transpose ## [,1] [,2] [,3] ## [1,] 1 2 3 Q &lt;- matrix(1:4,2,2) Q ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 t(Q) # transpose ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 Matrix Addition A &lt;- matrix(1:6, nrow = 2, ncol =3) B &lt;- matrix(2:7, nrow = 2, ncol =3) A+B ## [,1] [,2] [,3] ## [1,] 3 7 11 ## [2,] 5 9 13 A-B ## [,1] [,2] [,3] ## [1,] -1 -1 -1 ## [2,] -1 -1 -1 A+2 ## [,1] [,2] [,3] ## [1,] 3 5 7 ## [2,] 4 6 8 c &lt;- c(1,2) A+c ## [,1] [,2] [,3] ## [1,] 2 4 6 ## [2,] 4 6 8 Elementwise Product A &lt;- matrix(1:6, nrow = 2, ncol =3) B &lt;- matrix(1:2, nrow = 2, ncol =3) A*B ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 4 8 12 c &lt;- 2 A*c ## [,1] [,2] [,3] ## [1,] 2 6 10 ## [2,] 4 8 12 c &lt;- c(10,100) A*c ## [,1] [,2] [,3] ## [1,] 10 30 50 ## [2,] 200 400 600 c &lt;- c(10, 100, 1000) A*c # do you notice the pattern? ## [,1] [,2] [,3] ## [1,] 10 3000 500 ## [2,] 200 40 6000 Matrix Multiplication A &lt;- matrix(1:12, nrow = 3, ncol = 4) # 3x4 matrix t(A) # 4x3 matrix ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 t(A)%*%A #3x3 matrix, %*% = matrix multiplication ## [,1] [,2] [,3] [,4] ## [1,] 14 32 50 68 ## [2,] 32 77 122 167 ## [3,] 50 122 194 266 ## [4,] 68 167 266 365 B &lt;- matrix(1:9, nrow = 3, ncol =3) B%*%A ## [,1] [,2] [,3] [,4] ## [1,] 30 66 102 138 ## [2,] 36 81 126 171 ## [3,] 42 96 150 204 A%*%B # error, non-conformable arguments ## Error in A %*% B: non-conformable arguments Diagonal Matrix diag(1:4) # diagonal matrix with diagonal elements being 1:4 ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 2 0 0 ## [3,] 0 0 3 0 ## [4,] 0 0 0 4 A &lt;- matrix(1:9, 3, 3) A ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 diag(A) # find the diagonal of A ## [1] 1 5 9 How to create an identity matrix in R? Inverse The inverse of a \\(n \\times n\\) matrix \\(A\\), denoted by \\(A^{-1}\\), is a \\(n \\times n\\) matrix such that \\(AA^{-1} = A^{-1} A = I_n\\), where \\(I_n\\) is the \\(n\\times n\\) identity matrix. To find the inverse of \\(A\\) in R: solve A &lt;- matrix(c(1,0,0,3), 2, 2) solve(A) ## [,1] [,2] ## [1,] 1 0.0000000 ## [2,] 0 0.3333333 Some Statistical Applications I will mention a few connections of matrices with statistics. A dataset is naturally a matrix. Suppose that you have \\(n\\) people. You collected their health information: blood pressure, height, weight, age, whether they smoke (1 if yes, 0 if no), whether they drink (1/0), etc. Linear regression: we observe \\((x,y)\\), where \\(x\\) is a vector of covariates and \\(y\\) is your response. For example, \\(y\\) is the blood pressure, \\(x\\) is the collection of other health information. The linear regression model assumes that \\[y = \\beta_0 + x^T \\beta_1 + \\varepsilon,\\] where \\(\\varepsilon\\) is the error term. Our goal is to estimate \\(\\beta:=(\\beta_0, \\beta_1)\\). Let \\(X\\) be the design matrix. That is \\(X\\) is a \\(n \\times p\\) matrix where \\(n\\) is the number of observation, \\(p-1\\) is the number of covariates. The least squares solution for \\(\\beta\\) is \\[\\hat{\\beta} = (X^T X)^{-1}X^TY.\\] We will revisit linear regression later (I know some of you may not know linear regression). Correlation matrix, Covariance matrix. Let \\(X\\) be a random vector (column vector). The covariance matrix is defined as \\[\\Sigma := E[(X-E(X))(X-E(X))^T].\\] 1.4.4 Lists store an ordered set of elements like a vector can store different R data types (unlike a vector) # let&#39;s create some vectors (of different types) subject_name &lt;- c(&quot;John&quot;, &quot;Jane&quot;, &quot;Steve&quot;) # at this point, you should notice that meaningful names should be used for the variables temperature &lt;- c(98.1, 98.6, 101.4) flu_status &lt;- c(FALSE, FALSE, TRUE) # notice how we use _ to separate two words # this is one of the styles in coding, you should be consistent with your style data &lt;- list(fullname = subject_name, temperature = temperature, flu_status = flu_status) # you may wonder what is the meaning of temperature = temperature # in &quot;fullname = subject_name&quot; # on the left of = is the name of the 1st element of your list # on the right of = is the name of the variable that you want to # assign the value to the 1st element data ## $fullname ## [1] &quot;John&quot; &quot;Jane&quot; &quot;Steve&quot; ## ## $temperature ## [1] 98.1 98.6 101.4 ## ## $flu_status ## [1] FALSE FALSE TRUE To assess the element of a list: data$flu_status ## [1] FALSE FALSE TRUE data[c(&quot;temperature&quot;, &quot;flu_status&quot;)] ## $temperature ## [1] 98.1 98.6 101.4 ## ## $flu_status ## [1] FALSE FALSE TRUE data[2:3] # if you don&#39;t have the names ## $temperature ## [1] 98.1 98.6 101.4 ## ## $flu_status ## [1] FALSE FALSE TRUE 1.4.5 Data frames Data frame can be understood as a list of vectors, each having exactly the same number of values, arranged in a structure like a spreadsheet or database gender &lt;- c(&quot;MALE&quot;, &quot;FEMALE&quot;, &quot;MALE&quot;) blood &lt;- c(&quot;O&quot;, &quot;AB&quot;, &quot;A&quot;) pt_data &lt;- data.frame(subject_name, temperature, flu_status, gender, blood) pt_data ## subject_name temperature flu_status gender blood ## 1 John 98.1 FALSE MALE O ## 2 Jane 98.6 FALSE FEMALE AB ## 3 Steve 101.4 TRUE MALE A colnames(pt_data) ## [1] &quot;subject_name&quot; &quot;temperature&quot; &quot;flu_status&quot; &quot;gender&quot; &quot;blood&quot; pt_data$subject_name ## [1] &quot;John&quot; &quot;Jane&quot; &quot;Steve&quot; pt_data[c(&quot;temperature&quot;, &quot;flu_status&quot;)] ## temperature flu_status ## 1 98.1 FALSE ## 2 98.6 FALSE ## 3 101.4 TRUE pt_data[1, ] # like a matrix ## subject_name temperature flu_status gender blood ## 1 John 98.1 FALSE MALE O pt_data[, 2:3] ## temperature flu_status ## 1 98.1 FALSE ## 2 98.6 FALSE ## 3 101.4 TRUE Create a new column pt_data$temp_c &lt;- (pt_data$temperature - 32)*5/9 pt_data ## subject_name temperature flu_status gender blood temp_c ## 1 John 98.1 FALSE MALE O 36.72222 ## 2 Jane 98.6 FALSE FEMALE AB 37.00000 ## 3 Steve 101.4 TRUE MALE A 38.55556 pt_data$fever &lt;- (pt_data$temp_c &gt; 37.6) pt_data ## subject_name temperature flu_status gender blood temp_c fever ## 1 John 98.1 FALSE MALE O 36.72222 FALSE ## 2 Jane 98.6 FALSE FEMALE AB 37.00000 FALSE ## 3 Steve 101.4 TRUE MALE A 38.55556 TRUE 1.5 Operators Priority Operator Meaning 1 $ component selection 2 [ [[ subscripts, elements 3 ^ (caret) exponentiation 4 - unary minus 5 : sequence operator 6 %% %/% %*% modulus, integer divide, matrix multiply 7 * / multiply, divide 8 + - add, subtract 9 &lt; &gt; &lt;= &gt;= == != comparison 10 ! not 11 &amp; | &amp;&amp; || logical and, logical or 12 &lt;- -&gt; = assignments # $ for list, data frame, etc subject_name &lt;- c(&quot;John&quot;, &quot;Jane&quot;, &quot;Steve&quot;) temperature &lt;- c(98.1, 98.6, 101.4) flu_status &lt;- c(FALSE, FALSE, TRUE) data &lt;- list(fullname = subject_name, temperature = temperature, flu_status = flu_status) data$fullname ## [1] &quot;John&quot; &quot;Jane&quot; &quot;Steve&quot; pt_data &lt;- data.frame(subject_name, temperature, flu_status) pt_data$temperature ## [1] 98.1 98.6 101.4 # [ ], [[]] x &lt;- c(1,5, 7) x[2] ## [1] 5 data[[1]] ## [1] &quot;John&quot; &quot;Jane&quot; &quot;Steve&quot; # x^r = x to the power of r x &lt;- 2 x^4 # 16 ## [1] 16 # modulus 7%%2 # 7 divided by 2 equals 3 but it remains 1, modulus = reminder ## [1] 1 10%%3 ## [1] 1 20%%2 ## [1] 0 # integer division 7%/%2 ## [1] 3 20%/%3 ## [1] 6 Comparison # &lt;, &gt;, &lt;=, &gt;=, ==, != x &lt;- 2 x &gt; 3 ## [1] FALSE x &lt; 4 ## [1] TRUE x &lt;- c(1, 5, 7) x &lt; 3 # compare each element with 3 ## [1] TRUE FALSE FALSE x &gt;= 5 ## [1] FALSE TRUE TRUE x == 5 # if x is equal to 5, not x = 5 ## [1] FALSE TRUE FALSE x != 5 # if x is not equal to 5 ## [1] TRUE FALSE TRUE x &lt;- TRUE !x # not x ## [1] FALSE x &lt;- 2 x &lt;= 2 ## [1] TRUE !(x&lt;=2) ## [1] FALSE &amp; and &amp;&amp; indicate logical AND. The shorter form performs elementwise comparisons. The longer form examine only the first element of each vector. x &lt;- c(TRUE, FALSE, TRUE) y &lt;- c(FALSE, FALSE, TRUE) x&amp;y ## [1] FALSE FALSE TRUE x&amp;&amp;y ## [1] FALSE z &lt;- c(TRUE) x&amp;&amp;z ## [1] TRUE | and || indicate logical OR. The shorter form performs elementwise comparisons. The longer form examine only the first element of each vector. x &lt;- c(TRUE, FALSE, TRUE) y &lt;- c(FALSE, FALSE, TRUE) x|y ## [1] TRUE FALSE TRUE x||y ## [1] TRUE z &lt;- c(TRUE) x||z ## [1] TRUE Assignment # these assignments are the same, it is recommended to use &lt;- a &lt;- 2 a ## [1] 2 2 -&gt; b b ## [1] 2 c = 2 c ## [1] 2 Do !(x &gt; 1) &amp; (x &lt; 4) and !((x &gt; 1) &amp; (x &lt; 4)) give different results? 1.5.1 Vectorized Operators An important property of many of the operators is that they are vectorized. This means that the operation will be performed elementwise. x &lt;- c(1,2,3) y &lt;- c(5,6,7) x+y ## [1] 6 8 10 x*y ## [1] 5 12 21 2*x # you do not need to use c(2,2,2)*x ## [1] 2 4 6 y/2 # you do not need to use y/c(2,2,2) ## [1] 2.5 3.0 3.5 A &lt;- matrix(1:9, nrow = 3, ncol = 3) B &lt;- matrix(1:9, nrow = 3, ncol = 3) A+B ## [,1] [,2] [,3] ## [1,] 2 8 14 ## [2,] 4 10 16 ## [3,] 6 12 18 A*B # this is not matrix multiplication, but elementiwse multiplication ## [,1] [,2] [,3] ## [1,] 1 16 49 ## [2,] 4 25 64 ## [3,] 9 36 81 x &lt;- c(1, 3, 5) y &lt;- c(2, 2, 9) x &lt; y ## [1] TRUE FALSE TRUE 1.6 Built-in Functions Common mathematical functions sqrt, abs, sin, cos, log, exp. To get help on the usage of a function. Use ?. For example, if you want to know more about log. Type ?log in the console. You will then see that by default, log computes the natrual logarithms. Other useful functions Name Operations ceiling smallest integer greater than or equal to element floor largest integer less than or equal to element trunc ignore the decimal part round round up for positive and round down for negative sort sort the vector in ascending or descending order sum, prod sum and produce of a vector cumsum, cumprod cumulative sum and product min, max return the smallest and largest values range return a vector of length 2 containing the min and max mean return the sample mean of a vector var return the sample variance of a vector sd return the sample standard deviation of a vector seq generate a sequence of number rep replicate elements in a vector Note: If you have data \\(x_1,\\ldots,x_n\\), the sample variance is defined as \\[ S^2_n := \\frac{1}{n-1} \\sum^n_{i=1}(x_i-\\overline{x}_n)^2. \\] Note that we divide the sum by \\(n-1\\) but not \\(n\\). The sample standard deviation is the square root of the sample variance. x &lt;- 1:5 y &lt;- sqrt(x) y ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 ceiling(y) ## [1] 1 2 2 2 3 sum(x) ## [1] 15 prod(x) ## [1] 120 cumsum(x) ## [1] 1 3 6 10 15 cumprod(x) ## [1] 1 2 6 24 120 min(x) ## [1] 1 max(x) ## [1] 5 range(x) ## [1] 1 5 mean(x) ## [1] 3 var(x) ## [1] 2.5 rep(0, 10) # create a vector of length 10 with all elements being 0 ## [1] 0 0 0 0 0 0 0 0 0 0 rep(1, 10) # create a vector of length 10 with all elements being 1 ## [1] 1 1 1 1 1 1 1 1 1 1 1.6.1 sort() x &lt;- c(1, 5, 3, 10) sort(x) # default = ascending order ## [1] 1 3 5 10 sort(x, decreasing = TRUE) # descending order ## [1] 10 5 3 1 1.6.2 seq() This is an example of function with more than one argument. # seq(from, to) seq(1:5) ## [1] 1 2 3 4 5 seq(from = 1, to = 5) ## [1] 1 2 3 4 5 # seq(from, to, by) seq(1, 5, 2) ## [1] 1 3 5 seq(from = 1, to =5, by = 2) ## [1] 1 3 5 # seq(from, to, length) seq(0, 10, length = 21) ## [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 ## [17] 8.0 8.5 9.0 9.5 10.0 seq(from = 0, to = 10, length = 21) ## [1] 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 ## [17] 8.0 8.5 9.0 9.5 10.0 1.6.3 rep() # rep(data, times), try ?rep rep(0, 10) ## [1] 0 0 0 0 0 0 0 0 0 0 rep(c(1,2,3), 3) ## [1] 1 2 3 1 2 3 1 2 3 1.6.4 pmax, pmin x &lt;- c(1, 3, 5) y &lt;- c(2, 4, 4) max(x, y) # maximum of x and y ## [1] 5 min(x, y) # minimum of x and y ## [1] 1 pmax(x, y) # elementwise comparison ## [1] 2 4 5 pmin(x, y) # elementwise comparison ## [1] 1 3 4 1.7 Some Useful RStudio Shortcuts See also https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts Ctrl + 1: Move focus to the Source Editor (when you are in the Console) Ctrl + 2: Move focus to the Console (when you are in the source window) \\(\\uparrow\\) (the up arrow key on the keyboard): go to the previous command (in the console) \\(\\downarrow\\) (the down arrow key on the keyboard): go to the next command (in the console) Esc: Delete the current command/ Interrupt currently executing command Ctrl + Tab: go to the next tab 1.8 Exercises To test your understanding, try to evaluate the following code by hand and then check with the output from R. x &lt;- (10:1)[c(-1,-4)] x &lt;- x^2 x[5] # what do you expect to see? a&lt;-c(1:3,6,3+3,&quot;sta&quot;,3&gt;5) a #? typeof(a) #? length(a) #? x&lt;-rep(1:6,rep(1:3,2)) &gt; x%%2==0 #? &gt; x[x%%2==0] #? &gt; round(-3.7) #? &gt; trunc(-3.7) #? &gt; floor(-3.7) #? &gt; ceiling(-3.7) #? &gt; round(3.8) #? &gt; trunc(3.8) #? &gt; floor(3.8) #? &gt; ceiling(3.8) #? &gt; x&lt;-c(4,3,8,7,5,6,2,1) &gt; sort(x) #? &gt; order(x) #? &gt; sum(x)+prod(x) #? &gt; cumsum(x)+cumprod(x) #? &gt; max(x)+min(x) #? 1.9 Comments to Exercises These are comments but not answers but you can get the answers immediately by running the code. x &lt;- (10:1)[c(-1,-4)] # 10:1 will give you a vector with elements 10, 9, 8,...,1 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 # [c(-1, -4)] will remove the 1st and 4th elements in the vector # therefore 10 and 7 will be removed from 10:1 given x ## [1] 9 8 6 5 4 3 2 1 x &lt;- x^2 # ^2 will square each of the elements in the vector x[5] # 36 ## [1] 16 a&lt;-c(1:3,6,3+3,&quot;sta&quot;,3&gt;5) a # when you combine numeric, characters and logical values, the results become character ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;6&quot; &quot;6&quot; &quot;sta&quot; &quot;FALSE&quot; typeof(a) # character ## [1] &quot;character&quot; length(a) # ## [1] 7 x&lt;-rep(1:6,rep(1:3,2)) # we first evaluate rep(1:3, 2), which is # 1 2 3 1 2 3 # rep then replicates the elements by the corresponding number of times # 1 is repeated 1 time # 2 is repeated 2 times # 3 is repeated 3 times # 4 is repeated 1 time # 5 is repeated 2 times # 6 is repeated 3 times x%%2==0 # check if the modulus is 0 when x is divided by 2 ## [1] FALSE TRUE TRUE FALSE FALSE FALSE TRUE FALSE FALSE TRUE TRUE TRUE # this is equivalent to ask if the elements are even x[x%%2==0] # find out all the even elements ## [1] 2 2 4 6 6 6 # if you need to use these functions # you may try with a positive number and a negative number # to see if the results are what you want round(-3.7) # try round(-3.5), round(-3.4) ## [1] -4 trunc(-3.7) ## [1] -3 floor(-3.7) ## [1] -4 ceiling(-3.7) ## [1] -3 round(3.8) ## [1] 4 trunc(3.8) ## [1] 3 floor(3.8) ## [1] 3 ceiling(3.8) ## [1] 4 x&lt;-c(4,3,8,7,5,6,2,1) sort(x) # asecending order ## [1] 1 2 3 4 5 6 7 8 order(x) # from the result, can you guess what it does? ## [1] 8 7 2 1 5 6 4 3 # order(x) returns a permutation which rearranges its first argument into ascending or descending order # that is, x[order(x)] = sort(x) sum(x)+prod(x) ## [1] 40356 cumsum(x)+cumprod(x) ## [1] 8 19 111 694 3387 20193 40355 40356 max(x)+min(x) ## [1] 9 "],["probability.html", "Chapter 2 Probability 2.1 Probability Distributions 2.2 Simulation", " Chapter 2 Probability Optional Reading: R Cookbook Ch8 2.1 Probability Distributions Using the normal distribution as an example: Function Purpose dnorm Normal density pnorm Normal CDF qnorm Normal quantile function rnorm Normal random variables Examples Density of \\(N(2, 3^2)\\) at \\(5\\). dnorm(5, mean = 2, sd = 3) ## [1] 0.08065691 \\(P(X \\leq 3)\\), where \\(X \\sim N(2, 3^2)\\) pnorm(3, mean = 2, sd = 3) ## [1] 0.6305587 # &quot;mean =&quot; and &quot;sd =&quot; are optional pnorm(3, 2, 3) ## [1] 0.6305587 Generate 10 random variables, each follows \\(N(3, 4^2)\\). rnorm(10, 3, 4) ## [1] 0.5469957 2.8601586 -0.6245525 0.9439146 3.5881245 -2.3755044 3.6538463 ## [8] 0.8283631 4.6920674 -1.9264505 95th percenttile of \\(N(0, 1)\\). Find \\(q\\) such that \\(P(Z \\leq q) = 0.95\\) qnorm(0.95, 0, 1) ## [1] 1.644854 Plotting the normal density x &lt;- seq(-4, 4, by = 0.1) plot(x, dnorm(x), type=&quot;l&quot;, main = &quot;Density of N(0,1)&quot;) # &quot;l&quot; for lines 2.1.1 Common Distributions Common discrete distributions Discrete distribution R name Parameters Binomial binom n = number of trials; p = probability of success for one trial Geometric geom p = probability of success for one trial Negative binomial (NegBinomial) nbinom size = number of successful trials; either prob = probability of successful trial or mu = mean Poisson pois lambda = mean Common continuous distributions Continuous distribution R name Parameters Beta beta shape1; shape2 Cauchy cauchy location; scale Chi-squared (Chisquare) chisq df = degrees of freedom Exponential exp rate F f df1 and df2 = degrees of freedom Gamma gamma rate; either rate or scale Log-normal (Lognormal) lnorm meanlog = mean on logarithmic scale; sdlog = standard deviation on logarithmic scale Logistic logis location; scale Normal norm mean; sd = standard deviation Students t (TDist) t df = degrees of freedom Uniform unif min = lower limit; max = upper limit To get help on the distributions: ?dnorm ?dbeta ?dcauchy # the following distributions need to use different code ?TDist ?Chisquare ?Lognormal Examples (Using Binomial as an Example) dbinom(2, 10, 0.6) # p_X(2), p_X is the pmf of X, X ~ Bin(n=10, p=0.6) ## [1] 0.01061683 pbinom(2, 10, 0.6) # F_X(2), F_X is the CDF of X, X ~ Bin(n=10, p=0.6) ## [1] 0.01229455 qbinom(0.5, 10, 0.6) # 50th percentile of X ## [1] 6 rbinom(4, 10, 0.6) # generate 4 random variables from Bin(n=10, p=0.6) ## [1] 4 6 6 4 x &lt;- 0:10 plot(x, dbinom(x,10,0.6), type=&quot;h&quot;) # &quot;h&quot; for histogram like vertical lines 2.1.2 Exercises The average number of trucks arriving on any one day at a truck depot in a certain city is known to be 12. Assuming the number of trucks arriving on any one day has a Poisson distribution, what is the probability that on a given day fewer than 9 (strictly less than 9) trucks will arrive at this depot? ppois(8, 12) ## [1] 0.1550278 Let \\(Z \\sim N(0, 1)\\). Find \\(c\\) such that \\(P(Z \\leq c) = 0.1151\\) qnorm(0.1151) ## [1] -1.199844 \\(P(1\\leq Z \\leq c) = 0.1525\\) c &lt;- qnorm(pnorm(1)+0.1525) # draw a graph # test the answer pnorm(c) - pnorm(1) ## [1] 0.1525 \\(P(-c \\leq Z \\leq c) = 0.8164\\). # P(0 &lt;= Z &lt;= c) = 0.8164/2 # P(Z &lt;= c) = 0.8164/2 + 0.5 c &lt;- qnorm(0.8164/2+0.5) # test our answer pnorm(c)- pnorm(-c) ## [1] 0.8164 Plot the density of a chi-squared distribution with degrees of freedom \\(4\\), from \\(x=0\\) to \\(x=10\\). Find the 95th percentile of this distribution. # note that a chi-squared r.v. is nonnegative x &lt;- seq(0, 10, by = 0.1) plot(x, dchisq(x, df = 4), type=&quot;l&quot;) qchisq(0.95, df = 4) ## [1] 9.487729 Simulate \\(10\\) Bernoulli random variables with parameter \\(0.6\\). # Bernoulli(p) = Bin(1, p) rbinom(10, size = 1, prob = 0.6) ## [1] 1 1 1 1 1 0 0 0 0 0 Plot the Poisson pmf with parameter \\(2\\) from \\(x = 0\\) to \\(x = 10\\). x &lt;- 0:10 plot(x, dpois(x, 2), type=&quot;h&quot;) Draw a plot to illustrate that the 97.5th percentile of the t distribution will be getting closer to that of the standard normal distribution when the degrees of freedom increases. x &lt;- 10:200 plot(x, qt(0.975, df = x), type=&quot;l&quot;, ylim = c(1.9,2.3)) # add a horizontal line with value at qnorm(0.975) # lty = 2 for dashed line, check ?par abline(h = qnorm(0.975), lty = 2) # Therefore, for a large sample, t-test and z-test will give you similar result. 2.2 Simulation We have already seen how to use functions like runif, rnorm, rbinom to generate random variables. R actually generates pseudo-random number sequence (deterministic sequence of numbers that approximates the properties of random numbers) The pseduo-random number sequence will be the same if it is initialized by the same seed (can be used to reproduce the same simulation results or used to debug). # every time you run the first two lines, you get the same result set.seed(1) runif(5) ## [1] 0.2655087 0.3721239 0.5728534 0.9082078 0.2016819 # every time you run the following code, you get a different result runif(5) ## [1] 0.89838968 0.94467527 0.66079779 0.62911404 0.06178627 Sampling from discrete distributions Usage of sample: sample(x, size, replace = FALSE, prob = NULL) See also ?sample. sample(10) # random permutation of integers from 1 to 10 ## [1] 3 1 5 8 2 6 10 9 4 7 sample(10, replace = T) # sample with replacement ## [1] 5 9 9 5 5 2 10 9 1 4 sample(c(1, 3, 5), 5, replace = T) ## [1] 5 3 3 3 3 # simulate 20 random variables from a discrete distribution sample(c(-1,0,1), size = 20, prob = c(0.25, 0.5, 0.25), replace = T) ## [1] -1 1 1 -1 0 0 1 1 0 -1 0 0 0 0 0 1 1 0 -1 0 Example: Suppose we have a fair coin and we play a game. We flip the coin. We win $1 if the result is head and lose $1 if the result is tail. You play the game 100 times. You are interested in the cumulative profit. set.seed(1) # R actually generates pseudo random numbers # setting the seed ensure that each time you will get the same result # for illustration, code debugging, reproducibility profit &lt;- sample(c(-1, 1), size = 100, replace = T) plot(cumsum(profit), type=&quot;l&quot;) set.seed(2) profit &lt;- sample(c(-1, 1), size = 100, replace = T) plot(cumsum(profit), type=&quot;l&quot;) Example: You have two dice \\(A\\) and \\(B\\). For die \\(A\\), there are \\(6\\) sides with numbers \\(1,2,3,4,5,6\\) and the corresponding probability of getting these values are \\(0.1,0.1,0.1,0.1,0.1,0.5\\). For die \\(B\\), there are \\(4\\) sides with numbers \\(1,2,3,7\\) and the corresponding probability of getting these values are \\(0.3,0.2,0.3,0.2\\). You roll the two dice independently. Estimate \\(P(X &gt; Y)\\) using simulation, where \\(X\\) is the result from die \\(A\\) and \\(Y\\) is the result from die \\(B\\). n &lt;- 10000 # number of simulations X &lt;- sample(1:6, size = n, replace = TRUE, prob = c(0.1,0.1,0.1,0.1,0.1,0.5)) Y &lt;- sample(c(1,2,3,7), size = n, replace = TRUE, prob = c(0.3,0.2,0.3,0.2)) mean(X&gt;Y) ## [1] 0.6408 Why the sample mean approximates the required probability? Recall the strong law of large numbers (SLLN). Let \\(X_1,\\ldots,X_n\\) be independent and identically distributed random variables with mean \\(\\mu:=E(X)\\). Let \\(\\overline{X}_n:= \\frac{1}{n} \\sum^n_{i=1}X_i\\). Then \\[\\overline{X}_n \\stackrel{a.s.}{\\rightarrow} \\mu.\\] Note: a.s. means almost surely. The above convergence means \\(P(\\lim_{n\\rightarrow \\infty} \\overline{X}_n = \\mu) = 1\\). Note that (the expectation of an indicator random variable is the probability that the corresponding event will happen) \\[ P(X&gt;Y) = E(I(X&gt;Y)).\\] To apply SLLN, we just need to recognize the underlying random variable is \\(I(X&gt;Y)\\). Then, with probability \\(1\\), the sample mean \\[ \\frac{1}{n} \\sum^n_{i=1} I(X_i &gt; Y_i) \\rightarrow P(X&gt;Y).\\] The quantity on the LHS is what we compute in mean(X&gt;Y) (note that we are using vectorized comparison). We will see additional simulation examples after we talk about some programming in R There are many important topics that we will not discuss algorithms for simulating random variables inverse transform acceptance rejection Markov Chain Monte Carlo methods to reduce variance in simulation Control variates Antithetic variates Importance sampling "],["programming-in-r.html", "Chapter 3 Programming in R 3.1 Writing functions in R 3.2 Control Flow 3.3 Automatically Reindent Code 3.4 Speed Consideration 3.5 Another Simulation Example", " Chapter 3 Programming in R Optional reading: R Cookbook Ch 15, R for data science https://r4ds.had.co.nz/program-intro.html Hands-on programming with R: https://rstudio-education.github.io/hopr/ 3.1 Writing functions in R When you have to copy and paste some code more than 2 times, you should consider writing a function Writing a function can simplify your code and isolate the main part of your program General format of a function function_name &lt;- function(argument1, argument2) { statements } Example: Lets try to write a function to compute the sample variance. my_var &lt;- function(x){ mean_x &lt;- mean(x) n &lt;- length(x) return(sum((x - mean_x)^2)/(n-1)) } y &lt;- 1:9 my_var(y) ## [1] 7.5 var(y) # compared with the bulit-in function ## [1] 7.5 x &lt;- rnorm(1000, mean = 0, sd = 2) my_var(x) ## [1] 4.262595 var(x) # why the result is not equal to 2? ## [1] 4.262595 We can also write my_var2 &lt;- function(x){sum((x-mean(x))^2)/(length(x)-1)} The variable x is the argument to be passed into the function. The variables mean_x and n are local variables whose scope is within this function. y &lt;- 2 f &lt;- function(x) { y &lt;- x x &lt;- 4 y } y ## [1] 2 f(3) # output the value f(3) ## [1] 3 y # y is unchanged, y is defined in the global environment ## [1] 2 x ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found We shall write code using proper indentation (easier to read and debug) # with indentation (use this one) my_var &lt;- function(x){ mean_x &lt;- mean(x) n &lt;- length(x) return(sum((x - mean_x)^2)/(n-1)) } # no indentation my_var &lt;- function(x){ mean_x &lt;- mean(x) n &lt;- length(x) return(sum((x - mean_x)^2)/(n-1)) } The number of arguments passed to a function can be more than one Example: Write a function to compute the pooled sample standard deviation of two independent samples \\(x_1,\\ldots,x_n\\) and \\(y_1,\\ldots,y_m\\) of sizes \\(n\\) and \\(m\\). Recall that the pooled sample standard deviation is defined as: \\[ S_p := \\sqrt{\\frac{(n-1)S^2_X + (m-1)S^2_Y}{m+n-2}}, \\] where \\(S^2_X\\) and \\(S^2_Y\\) are the sample variances of \\(x_1,\\ldots,x_n\\) and \\(y_1,\\ldots,y_m\\), respectively. pooled_sd &lt;- function(x, y) { n &lt;- length(x) m &lt;- length(y) return(sqrt(((n-1)*var(x)+(m-1)*var(y))/(m+n-2))) } Remark: if the final statement will output something, it will be the output of the function. You can also use return() as above. That is, pooled_sd and pooled_sd2 are exactly the same. pooled_sd2 &lt;- function(x, y) { n &lt;- length(x) m &lt;- length(y) sqrt(((n-1)*var(x)+(m-1)*var(y))/(m+n-2)) } You can return more than one value in a function my_var_sd &lt;- function(x){ mean_x &lt;- mean(x) n &lt;- length(x) my_var &lt;- sum((x - mean_x)^2)/(n-1) return(c(my_var, sqrt(my_var))) } You may also return a list my_var_sd &lt;- function(x){ mean_x &lt;- mean(x) n &lt;- length(x) my_var &lt;- sum((x - mean_x)^2)/(n-1) output &lt;- list(var = my_var, sd = sqrt(my_var)) return(output) } Example: write a function called my_summary that will output a list with elements being the mean, sd, median, min and max of a given vector. my_summary &lt;- function(x){ output &lt;- list(mean = mean(x), sd = sd(x), median = median(x), min = min(x), max = max(x)) return(output) } my_summary(1:10) ## $mean ## [1] 5.5 ## ## $sd ## [1] 3.02765 ## ## $median ## [1] 5.5 ## ## $min ## [1] 1 ## ## $max ## [1] 10 Define a function with default value my_power = function(x, p = 2) { return(x^p) } my_power(3) # by default, p = 2, will compute 3^2 ## [1] 9 my_power(3, 3) # will compute 3^3 ## [1] 27 3.2 Control Flow 3.2.1 for loop You can use a for loop when you know how many times you will loop. Syntax: for (var in sequence) { statement # do this statement for each value of i } Examples: for (i in 1:5) { # note: you do not have to define i beforehand print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 for (i in c(1,3,6)) { print(i) } ## [1] 1 ## [1] 3 ## [1] 6 Examples Write R code to find \\(\\sum^{10}_{i=1} \\sum^4_{j=1} \\frac{i^2}{(i+j)^2}\\). sum &lt;- 0 for (i in 1:10) { for (j in 1:4) { sum &lt;- sum + i^2/(i+j)^2 } } sum ## [1] 18.26491 Write R code to find \\(\\sum^{10}_{i=1} \\sum^i_{j=1} \\frac{i^2}{(i+j)^3}\\). sum &lt;- 0 for (i in 1:10) { for (j in 1:i) { sum &lt;- sum + i^2/(i+j)^3 } } sum ## [1] 2.779252 3.2.2 while loop You can use a while loop if you want to loop until a specific condition is met. For example, when you minimize a function numerically using some iterative algorithm, you may want to stop when the objective value does not change much. You may not know how many loops are required in advance so that a while loop may be better than a for loop in this application. Syntax: while (condition) { statement # while the condition is TRUE, do this } A simple example: i &lt;- 1 while (i &lt; 6) { print(i) i &lt;- i+1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 # What happen if you change &quot;i &lt; 6&quot; to &quot;i &lt;= 6&quot;? Ans: will print 1 to 6 # What happen if you change &quot;i &lt; 6&quot; to &quot;i &lt;= 5&quot;? Ans: outputs are the same Another example: # find the smallest n such that 1^2+ 2^2+ ... + n^2 &gt; 65 sum &lt;- 0 i &lt;- 1 while (sum &lt; 65) { sum &lt;- sum + i^2 print(c(i, sum)) i &lt;- i+1 } ## [1] 1 1 ## [1] 2 5 ## [1] 3 14 ## [1] 4 30 ## [1] 5 55 ## [1] 6 91 i # 6 ## [1] 7 3.2.3 if (cond) Syntax: if (condition) { statement # do this if the condition is TRUE } Example: write a function that outputs positive if a positive number is entered. # check if a number if positive my_pos &lt;- function(x) { if (x &gt; 0) { print(&quot;positive&quot;) } } my_pos(-2) my_pos(2) ## [1] &quot;positive&quot; 3.2.4 if (cond) else expr Syntax if (condition) { statement1 # do this if condition is TRUE } else { statement2 # do this if condition is FALSE } Example: # write my own absolute value function my_abs &lt;- function(x) { if (x&gt;=0) { return(x) } else { return(-x) } } my_abs(-2) ## [1] 2 my_abs(3) ## [1] 3 my_abs(0) ## [1] 0 Error-handling in a function: my_sqrt = function(x) { if (x &gt;= 0) { print(sqrt(x)) # do this if x &gt;= 0 } else { cat(&quot;Error: this is a negative number!&quot;) # do this otherwise } } my_sqrt(-2) ## Error: this is a negative number! 3.2.5 If else ladder Syntax # Example if (condition1) { statement1 } else if (condition2) { statement2 } else if (condition1) { statement3 } Example: score_to_grade = function(x) { if (x&gt;=90) { cat(&quot;A+&quot;) } else if (x &gt;=85) { cat(&quot;A&quot;) } else if (x &gt;=80) { cat(&quot;A-&quot;) } else { cat(&quot;B+ or below&quot;) } } # after you write the function, you should check each case carefully score_to_grade(92) ## A+ score_to_grade(88) ## A score_to_grade(83) ## A- score_to_grade(78) ## B+ or below 3.3 Automatically Reindent Code To indent a block of code, highlight the text in RStudio, then press Ctrl+i (Windows or Linux) or press Cmd+i (Mac). Poor indentation, difficult to read for (i in 1:5) { if (i &gt;= 3) { print(i**2) } else { print(i * 3) } } ## [1] 3 ## [1] 6 ## [1] 9 ## [1] 16 ## [1] 25 Highlight the block of code, press Ctrl+i or Cmd+i for (i in 1:5) { if (i &gt;= 3) { print(i**2) } else { print(i * 3) } } ## [1] 3 ## [1] 6 ## [1] 9 ## [1] 16 ## [1] 25 3.4 Speed Consideration While the computing power is getting stronger and stronger, we should still write code that runs efficiently. # suppose we want to simulate 200,000 normal random variables n &lt;- 200000 x &lt;- rep(0, n) # create a vector for storage of the values initial_time &lt;- proc.time() for (i in 1:n) { x[i] &lt;- rnorm(1) } proc.time() - initial_time ## user system elapsed ## 0.43 0.00 0.42 n &lt;- 200000 x &lt;- rep(0, n) # create a vector for storage of the values # Alternatively system.time({ for (i in 1:n) { x[i] &lt;- rnorm(1) } }) ## user system elapsed ## 0.35 0.00 0.35 The user time is the CPU time charged for the execution of user instructions of the calling process. The system time is the CPU time charged for execution by the system on behalf of the calling process. A much more efficient way for the same task is to use system.time({ n &lt;- 200000 x &lt;- rnorm(n) }) ## user system elapsed ## 0.02 0.00 0.01 Another example: set.seed(1) x &lt;- rnorm(2e6) y &lt;- rnorm(2e6) v &lt;- rep(0, 2e6) system.time({ for (i in 1:length(x)){ v[i] &lt;- x[i]+y[i] } }) ## user system elapsed ## 0.16 0.00 0.16 system.time(v &lt;- x + y) ## user system elapsed ## 0 0 0 The general rule is to use vectorized operations whenever possible and to avoid using for loops. We use a for loop when the code is not time-consuming or when the code is hard to write without using a for loop. A more advanced option is to combine C++ with R using the package rcpp. That is, we can write the most time-consuming part of the R code in C++, which could run many times faster (will not be discussed in this course). See also http://www.noamross.net/archives/2014-04-16-vectorization-in-r-why/ 3.5 Another Simulation Example A simple model on the stock return assumes that (i) \\[r_{t+1} := \\log \\frac{P_{t+1}}{P_t} \\sim N(\\mu,\\sigma^2), \\] where \\(r_{t+1}\\) is the log-return at Day \\(t+1\\), \\(P_t\\) is the stock price at the end of Day \\(t\\); (ii) \\(r_1,r_2,\\ldots\\) are iid. Simple algebra shows that \\[P_{t+1} = P_t e^{r_{t+1}}\\] and \\[P_{t+1} = P_0 e^{ \\sum^{t+1}_{i=1} r_i}.\\] Suppose that the current price of a certain stock \\(P_0\\) is \\(100\\), \\(\\mu = 0.0002\\) and \\(\\sigma = 0.015\\). Using simulation, estimate the probability that the price is below $95 at the close of at least one of the next 30 trading days. no_sim &lt;- 10000 # number of simulation below &lt;- rep(0, no_sim) for (i in 1:no_sim) { price &lt;- 100*exp(cumsum(rnorm(30, mean = 0.0002, sd = 0.015))) below[i] &lt;- min(price) &lt; 95 } mean(below) ## [1] 0.4384 "],["creating-some-basic-plots.html", "Chapter 4 Creating Some Basic Plots 4.1 Scatter Plot 4.2 Line Graph 4.3 Bar Chart 4.4 Histogram 4.5 Box Plot 4.6 Plotting a function curve 4.7 More on plots with base R 4.8 Summary of ggplot", " Chapter 4 Creating Some Basic Plots The base R contains many basic methods for producing graphics. We will learn some of them in this chapter. For more elegant plots, we will use the package ggplot2. We will use some simple datasets in base R to illustrate how to create some basic plots in this chapter. In this next chapter, we will discuss how to input our own data and transform them. Reference: R graphics cookbook, R for data science, R Cookbook. We will load the package tidyverse. An R package is a collection of functions, data, and documentation that extends the capabilities of base R. You have to install the package before you can use it. install.packages(&quot;tidyverse&quot;) Load the library library(tidyverse) # load the tidyverse package (which contains ggplot2) if we want to make it clear what package an object/ function comes from, use package name followed by two colons, like dplyr::mutate(). 4.1 Scatter Plot Lets take a look at the mtcars dataset. This dataset comes with base R. head(mtcars) # this is a data frame ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 str(mtcars) # display the structure of the data frame ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... mpg: miles/gallon wt: weight (1000lbs) Scatter plot with base graphics # x-axis: mtcars$wt # y-axis: mtcars$mpg plot(x = mtcars$wt, y = mtcars$mpg) # &quot;x=&quot;, &quot;y=&quot; are optional You can produce the same plot with plot(mtcars$wt, mtcars$mpg) Scatter plot with ggplot2 ggplot(data = mtcars, aes(x = wt, y = mpg)) + geom_point() Scatter plot with base graphics (when you only have \\(x\\) and \\(y\\) but not a dataset) set.seed(1) x &lt;- rnorm(100, 0, 1) y &lt;- 2*x + rnorm(100, 0, 1) plot(x, y) Scatter plot with ggplot2 (when you only have \\(x\\) and \\(y\\) but not a dataset) set.seed(1) x &lt;- rnorm(100, 0, 1) y &lt;- 2*x + rnorm(100, 0, 1) ggplot(mapping=aes(x=x, y=y)) + # by default, data = NULL geom_point() 4.2 Line Graph The dataset pressure (also in base R) contains the relation between temperature in degrees Celsius and vapor pressure of mercury in millimeters (of mercury). Line graph with base graphics # the only difference from a scatter plot is that we add type=&quot;l&quot; plot(pressure$temperature, pressure$pressure, type = &quot;l&quot;) #l = line Line graph with base graphics with points plot(pressure$temperature, pressure$pressure, type = &quot;l&quot;) points(pressure$temperature, pressure$pressure) # add some points Line graph with base graphics with another line and points (with color) plot(pressure$temperature, pressure$pressure, type = &quot;l&quot;) points(pressure$temperature, pressure$pressure) # the additional line may not have a physical meaningful # just an illustration of how to add a line wit base graphics lines(pressure$temperature, pressure$pressure/2, col= &quot;red&quot;) points(pressure$temperature, pressure$pressure/2, col= &quot;red&quot;) Colors in R You can go to https://www.r-graph-gallery.com/ggplot2-color.html and read more about colors in R. For example, you can specify the color by name, rgb, number and hex code. plot(pressure$temperature, pressure$pressure, type = &quot;l&quot;, col = rgb(0.1, 0.2,0.5,1)) lines(pressure$temperature, pressure$pressure/2, type = &quot;l&quot;, col = 2) lines(pressure$temperature, pressure$pressure*2, col = &quot;#8B2813&quot;) lines(pressure$temperature, pressure$pressure*3, col = &quot;cornflowerblue&quot;) Line graph with ggplot2 ggplot(data = pressure, aes(x=temperature, y=pressure)) + geom_line() Line graph with ggplot2 with points ggplot(data = pressure, aes(x=temperature, y=pressure)) + geom_line() + geom_point() Line graph with ggplot2 with another line and points (with color) ggplot(data = pressure, aes(x=temperature, y=pressure)) + geom_line()+ geom_point()+ geom_line(aes(x=temperature, y=pressure/2), color=&quot;red&quot;) + geom_point(aes(x=temperature, y=pressure/2), color = &quot;#8B2813&quot;) Remark: it is common with ggplot() to split the command on multiple lines, ending each line with a + so that R knows that the command will continue on the next line. 4.3 Bar Chart Two types of bar charts: Bar chart of values. x-axis: discrete variable, y-axis: numeric data (not necessarily count data) Bar chart of count. x-axis: discrete variable, y-axis: count of cases in the discrete variable Remark: for histogram: x-axis = continuous variable, y-axis = count of cases in the interval. The BOD data set has 6 rows and 2 columns giving the biochemical oxygen demand versus time in an evaluation of water quality. # instead of using head(BOD) and str(BOD), we can also change it to a &quot;tibble&quot; # we can view the first few lines and the data structure as_tibble(BOD) ## # A tibble: 6 x 2 ## Time demand ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 8.3 ## 2 2 10.3 ## 3 3 19 ## 4 4 16 ## 5 5 15.6 ## 6 7 19.8 Bar chart of values with base graphics # names.arg = a vector of names to be plotted below each bar or group of bars. barplot(BOD$demand, names.arg=BOD$Time) Bar chart of counts with base graphics In the dateset mtcars, cylis the number of cylinders in the car. The possible values are \\(4, 6\\), and \\(8\\). We first find the count of each unique value in mtcars$cyl: table(mtcars$cyl) ## ## 4 6 8 ## 11 7 14 To plot the bar chart, we use barplot(table(mtcars$cyl)) Bar chart with values with ggplot2 We first make the Time variable to a factor: BOD2 = BOD BOD2$Time = as.factor(BOD2$Time) ggplot(BOD2, aes(x=Time, y = demand)) + geom_col() What will happen if we do not make Time as a factor: ggplot(BOD, aes(x=Time, y = demand)) + geom_col() Bar chart of counts with ggplot2 # the y position is calculated by counting the number of rows for each value of cyl ggplot(mtcars, aes(x=cyl)) + geom_bar() 4.4 Histogram mpg in mtcars is the miles/gallon of the car. It is a continuous variable. Histogram with base graphics hist(mtcars$mpg) Histogram with base graphics # Specify approximate number of bins with &quot;breaks&quot; hist(mtcars$mpg, breaks=10) Histogram with ggplo2 ggplot(mtcars, aes(x=mpg)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mtcars, aes(x=mpg)) + geom_histogram(binwidth = 2.5) Remark: different bin widths will give you histograms with different looks. 4.5 Box Plot Lets take a look at another dataset ToothGrowth. In particular, supp is a factor. as_tibble(ToothGrowth) ## # A tibble: 60 x 3 ## len supp dose ## &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10 VC 0.5 ## 7 11.2 VC 0.5 ## 8 11.2 VC 0.5 ## 9 5.2 VC 0.5 ## 10 7 VC 0.5 ## # ... with 50 more rows Box plot with basic graphics (using plot) # if x is a factor, use the following code plot(x = ToothGrowth$supp, y = ToothGrowth$len) Box plot with basic graphics (using boxplot) # len ~ supp is an example of a &quot;formula&quot; (y ~ x) boxplot(len ~ supp, data = ToothGrowth) Box plot with basic graphics + interaction of two variables on x-axis (using boxplot) boxplot(len ~ supp + dose, data = ToothGrowth) Box plot with ggplot2 ggplot(ToothGrowth, aes(x=supp, y=len)) + geom_boxplot() Box plot with ggplot2 + interaction of two variables on x-axis ggplot(ToothGrowth, aes(x=interaction(supp, dose), y=len)) + geom_boxplot() What will happen if dose take a lot more values? ggplot(ToothGrowth, aes(x=interaction(supp, dose +1:5), y=len)) + geom_boxplot() 4.6 Plotting a function curve curve(x^3 - 5*x, from = -4, to = 4) Alternatively: x &lt;- seq(-4, 4, len = 1000) plot(x, x^3-5*x, type=&quot;l&quot;) Plotting a built-in function curve(dnorm(x), from=-4,to=4) Plotting a self-defined function my_function &lt;- function(x) { 1/(1+exp(-x+10)) } curve(my_function, from = 0, to = 20) Plotting a function with additional arguments curve(dnorm(x, mean = 2, sd = 3), from=-4,to=4) 4.7 More on plots with base R 4.7.1 Multi-frame plot To create a 3x2 multi-frame plot. Use par(mfrow=c(3, 2)). set.seed(1) x &lt;- rnorm(100, 50, 5) y &lt;- x + rnorm(100, 2, 2) # create a 2x2 multi-frame plot par(mfrow=c(2,2)) hist(x) hist(y,breaks=10) plot(x,y) boxplot(x,y) 4.7.2 Type of Plot Option Type type=\"p\" Points (default) type=\"l\" Lines connecting the data points type=\"b\" Points and non-overlapping lines type=\"h\" Height lines type=\"o\" Points and overlapping lines par(mfrow=c(3,2)) x &lt;- -5:5 y &lt;- x^2 plot(x, y) plot(x, y, type=&quot;p&quot;) plot(x, y, type=&quot;l&quot;) plot(x, y, type=&quot;b&quot;) plot(x, y, type=&quot;h&quot;) plot(x, y, type=&quot;o&quot;) 4.7.3 Parameters of a plot Parameter Meaning type See Type of Plot main Title sub Subtitle xlab x-axis label ylab y-axis label xlim x-axis range ylim y-axis range pch Symbol of data points col Color of data points lty Type of the line To illustrate some of the components: set.seed(1) x &lt;- rnorm(100, 50, 15) y &lt;- x + rnorm(100, 2, 13) plot(x, y, col = &quot;red&quot;, pch = 15, main =&quot;This is the title&quot;, xlim=c(0, 100), ylim=c(0,100), xlab=&quot;name of x-axis&quot;, ylab=&quot;name of y-axis&quot;) 4.7.4 Elements on plot Function Description abline(c,m) plot the line y= mx +c abline(h = a) plot the line y = a abline(v = b) plot the line x = b lines(x,y) line joining points with coordinates (x,y) set.seed(1) x &lt;- rnorm(100, 50, 15) y &lt;- x + rnorm(100, 2, 13) plot(x,y) # connect the points (20, 20), (30, 80), (40, 40) with a line lines(x=c(20, 30, 40),y=c(20, 80, 40), col = &quot;red&quot;) abline(v=60, col =&quot;blue&quot;) 4.8 Summary of ggplot Plot geom scatter plot geom_point() line graph geom_line() bar chart of values geom_col() bar chart of counts geom_bar() histogram geom_histogram() box plot geom_boxplot() "],["managing-data-with-r.html", "Chapter 5 Managing Data with R 5.1 Missing Values 5.2 Saving, loading, and removing R data structures 5.3 Importing and saving data from CSV files", " Chapter 5 Managing Data with R Optional Reading: ML with R Ch2 5.1 Missing Values Missing values are common in real datasets. NA is used to denote missing values. (x &lt;- c(1,2,3, NA, 4, NA, 4)) # we can use (x&lt;-1) to assign 1 to x and display x at the same time ## [1] 1 2 3 NA 4 NA 4 mean(x) # mean cannot be computed when missing values exist ## [1] NA mean(x, na.rm = TRUE) # NA values will be removed before computing mean ## [1] 2.8 sd(x) # sd cannot be computed when missing values exist ## [1] NA sd(x, na.rm = TRUE) # NA values will be removed before computing SD ## [1] 1.30384 is.na(x) # logical vector ## [1] FALSE FALSE FALSE TRUE FALSE TRUE FALSE x[!is.na(x)] #select the elements with non-missing valuess ## [1] 1 2 3 4 4 na.omit(x) # select the elements with non-missing valuess ## [1] 1 2 3 4 4 ## attr(,&quot;na.action&quot;) ## [1] 4 6 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; 5.2 Saving, loading, and removing R data structures Removing all objects in R: rm(list=ls()) ls() returns a vector of all data structures currently in memory x &lt;- c(1,2,3) y &lt;- c(4,5,6) ls() ## [1] &quot;x&quot; &quot;y&quot; To remove x from the memory rm(x) x # because we have deleted x, an error message occurs ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found Saving objects to a file (regardless of whether they are vectors, factors, lists, etc) A &lt;- matrix(1:9, 3, 3) f &lt;- function(x){ return(1) } save(A, f, file = &quot;my_data.RData&quot;) Loading objects from a .RData file. rm(list=ls()) # remove everything load(&quot;my_data.RData&quot;) A ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 f ## function(x){ ## return(1) ## } 5.3 Importing and saving data from CSV files Finding current directory getwd() ## [1] &quot;C:/Queens Teaching/Teaching/STAT 362/website&quot; If you use mac, you will probably see \"/Users/..../\". Setting working directory setwd(&quot;C:/Queens Teaching/Teaching/STAT 362/Notes&quot;) # use /, not \\ If you use mac, change the above code accordingly. Writing to a file my_data &lt;- data.frame(x = c(1,2,3), y = c(4,5,6)) my_data ## x y ## 1 1 4 ## 2 2 5 ## 3 3 6 library(tidyverse) write_csv(my_data, &quot;C:/Queens Teaching/Teaching/STAT 362/my_data.csv&quot;) Reading a csv file A comma-separated values (CSV) file is a delimited text file that uses a comma to separate values. If we use read_csv from the package tidyverse, the resulting object is a tibble. If we use read.csv from base R, the resulting object is a data frame. See R for data science (https://r4ds.had.co.nz/data-import.html) for a discussion on the differences between read.csv and read_csv. A tibble allows us to perform different types of transformation (next chapter). my_data &lt;- read_csv(&quot;C:/Queens Teaching/Teaching/STAT 362/my_data.csv&quot;) ## ## -- Column specification -------------------------------------------------------------- ## cols( ## x = col_double(), ## y = col_double() ## ) "]]
